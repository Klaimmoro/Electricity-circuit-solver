use indexmap::IndexMap;
use crate::kernel::{circuit::circuit::Circuit, entities::{equation_complex::EquationComplex, expression_complex::ExpressionComplex}};
use nalgebra::{Complex, DMatrix, DVector};
///
/// Struct that realize MNA (modified nodal analysis)
pub struct AC { 
    _dbgid: String,
    /// where store String equation's generated by MNA
    equations: Vec<EquationComplex>,
    /// where store result of solved matrix by Gaussian
    result: IndexMap<String,Complex<f32>>,
    circuit: Circuit,
}
//
//
impl AC {
    ///
    /// Struct constructor
    pub fn new(circuit: Circuit) -> Self {
        Self { 
            _dbgid: String::from("MNA"), 
            equations: Vec::new(),
            result: IndexMap::new(),
            circuit,
        }
    }
    ///
    /// Method to solve circuit by MNA
    pub fn solve(&mut self) -> IndexMap<String,Complex<f32>> {
        self.equations = self.equations();
        let mut x: Vec<IndexMap<String,Complex<f32>>> = Vec::new();
        let mut a: Vec<IndexMap<String,Complex<f32>>> = Vec::new();
        let mut right_row_map: IndexMap<String,Complex<f32>> = IndexMap::new();
        for equation in self.equations.iter() {
            let mut left_row_map: IndexMap<String,Complex<f32>> = IndexMap::new();
            for variable in &self.result {
                equation.left_side
                    .iter()
                    .filter(|expr| expr.numerator[1..] == *variable.0)
                    .for_each(|expr| {
                        left_row_map
                            .entry(variable.0.clone())
                            .and_modify(|val | *val += expr.denominator)
                            .or_insert(expr.denominator);
                });
                if !left_row_map.contains_key(variable.0) {
                    left_row_map.insert(variable.0.clone(), Complex::new(0.0, 0.0));
                }
            }
            if equation.right_side.len()== 1 && equation.right_side[0].numerator == "0" {
                right_row_map.insert(right_row_map.len().to_string(), Complex::new(0.0, 0.0));
            } else {
                for right_side in equation.right_side.iter() {
                    right_row_map.entry(right_side.numerator.clone()).and_modify(|val | *val += right_side.denominator).or_insert(right_side.denominator);
                }
            }
            a.push(left_row_map);
        }
        x.push(right_row_map);
        let mut coeffs: Vec<Vec<Complex<f32>>> = Vec::new();
        let mut constants: Vec<Complex<f32>> = Vec::new();  
        for vec in a.iter() {
            let row: Vec<Complex<f32>> = vec.values().cloned().collect();
            coeffs.push(row);
        }
        for vec in x.iter() {
            for (_, value) in vec.iter() {
                constants.push(*value);
            }
        }
        if let Some(solution) = Self::solve_system(coeffs, constants) {
            let keys: Vec<String> = self.result.keys().cloned().collect();
            for (i, key) in keys.iter().enumerate() {
                if i < solution.len() {
                    self.result.insert(key.clone(), solution[i]);
                }
            }
            return self.result.clone()
        }
        self.result.clone()
    }
    ///
    /// Gaussian elimination
    fn solve_system(coeffs: Vec<Vec<Complex<f32>>>, constants: Vec<Complex<f32>>) -> Option<DVector<Complex<f32>>> {
        let n = coeffs.len();
    
        if n == 0 || coeffs[0].len() != n || constants.len() != n {
            println!("Ошибка: некорректные размеры матрицы.");
            return None;
        }
    
        // Создаем DMatrix из коэффициентов
        let matrix = DMatrix::<Complex<f32>>::from_row_iterator(n, n, coeffs.into_iter().flatten());
    
        // Создаем DVector из констант
        let vector = DVector::<Complex<f32>>::from_vec(constants);
    
        // Решаем систему
        match matrix.lu().solve(&vector) {
            Some(solution) => Some(solution),
            None => {
                println!("Система несовместна или матрица вырождена.");
                None
            }
        }
    }
    ///
    /// Method to generate equations by MNA
    fn equations(&mut self) -> Vec<EquationComplex> {
        for node in &self.circuit.nodes {
            self.result.entry(node.id.clone()).or_insert(Complex::new(0.0, 0.0));
            let mut equation: EquationComplex = EquationComplex::new();
            for element in &node.elements {
                match element {
                    crate::kernel::elements::element_type::ElementType::Resistor(resistor) => {
                        if resistor.connection.from == node.id {
                            if resistor.connection.to == "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(resistor.resistance, 0.0),
                                    }
                                );
                            } else if resistor.connection.from == "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(resistor.resistance, 0.0),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",resistor.connection.to),
                                        denominator: Complex::new(-resistor.resistance, 0.0),
                                    }
                                );
                            } else {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(resistor.resistance, 0.0),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",resistor.connection.to),
                                        denominator: Complex::new(-resistor.resistance, 0.0),
                                    }
                                );
                            }
                        } else {
                            if resistor.connection.from == "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(resistor.resistance, 0.0),
                                    }
                                );
                            } else if resistor.connection.to== "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(resistor.resistance, 0.0),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",resistor.connection.from),
                                        denominator: Complex::new(-resistor.resistance, 0.0),
                                    }
                                );
                            } else {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(resistor.resistance, 0.0),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",resistor.connection.from),
                                        denominator: Complex::new(-resistor.resistance, 0.0),
                                    }
                                );
                            }
                        }
                    },
                    crate::kernel::elements::element_type::ElementType::VoltageSourceDC(voltage_source_dc) => {
                        self.result.entry(voltage_source_dc.id.clone()).or_insert(Complex::new(0.0, 0.0));
                        if voltage_source_dc.connection.from == "Ground" {
                            let eq = EquationComplex {
                                left_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("-{}",voltage_source_dc.connection.to), 
                                            denominator: Complex::new(-1.0, 0.0) 
                                        }
                                    ],
                                right_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("+{}",voltage_source_dc.id), 
                                            denominator: Complex::new(voltage_source_dc.voltage, 0.0)
                                        }
                                    ],
                            };
                            if !self.equations.contains(&eq) {
                                self.equations.push(eq);
                            };
                        } else if voltage_source_dc.connection.to == "Ground" {
                            let eq = EquationComplex {
                                left_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("+{}",voltage_source_dc.connection.from), 
                                            denominator: Complex::new(1.0, 0.0)
                                        }
                                    ],
                                right_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("+{}",voltage_source_dc.id), 
                                            denominator: Complex::new(voltage_source_dc.voltage, 0.0)
                                        }
                                    ],
                            };
                            if !self.equations.contains(&eq) {
                                self.equations.push(eq)
                            }
                        } else {
                            let eq = EquationComplex {
                                left_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("+{}",voltage_source_dc.connection.from), 
                                            denominator: Complex::new(1.0, 0.0)
                                        },
                                        ExpressionComplex { 
                                            numerator: format!("-{}",voltage_source_dc.connection.to), 
                                            denominator: Complex::new(-1.0, 0.0) 
                                        }
                                    ],
                                right_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("+{}",voltage_source_dc.id), 
                                            denominator: Complex::new(voltage_source_dc.voltage, 0.0)
                                        }
                                    ],
                            };
                            if !self.equations.contains(&eq) {
                                self.equations.push(eq)
                            }
                        }
                        if voltage_source_dc.connection.from == node.id {
                            equation.left_side.push(
                                ExpressionComplex {
                                    numerator: format!("+{}",voltage_source_dc.id),
                                    denominator: Complex::new(1.0, 0.0),
                                }
                            )
                        } else {
                            equation.left_side.push(
                                ExpressionComplex {
                                    numerator: format!("-{}",voltage_source_dc.id),
                                    denominator: Complex::new(-1.0, 0.0),
                                }
                            )
                        }
                    },
                    crate::kernel::elements::element_type::ElementType::CurrentSourceDC(current_source_dc) => {
                        if current_source_dc.connection.to == node.id {
                            equation.right_side.push(
                                ExpressionComplex {
                                    numerator: format!("-{}",current_source_dc.id),
                                    denominator: Complex::new(-current_source_dc.currence, 0.0),
                                }
                            )
                        } else {
                            equation.right_side.push(
                                ExpressionComplex {
                                    numerator: format!("+{}",current_source_dc.id),
                                    denominator: Complex::new(current_source_dc.currence, 0.0),
                                }
                            )
                        }
                    },
                    crate::kernel::elements::element_type::ElementType::CurrentSourceAC(current_source_ac) => {
                        if current_source_ac.connection.to == node.id {
                            equation.right_side.push(
                                ExpressionComplex {
                                    numerator: format!("-{}",current_source_ac.id),
                                    denominator: Complex::new(
                                        -current_source_ac.currence * current_source_ac.phase.to_radians().cos(),
                                        current_source_ac.currence * current_source_ac.phase.to_radians().sin()
                                    )
                                }
                            )
                        } else {
                            equation.right_side.push(
                                ExpressionComplex {
                                    numerator: format!("+{}",current_source_ac.id),
                                    denominator: Complex::new(
                                        current_source_ac.currence * current_source_ac.phase.to_radians().cos(),
                                        current_source_ac.currence * current_source_ac.phase.to_radians().sin()
                                    )
                                }
                            )
                        }
                    },
                    crate::kernel::elements::element_type::ElementType::VoltageSourceAC(voltage_source_ac) => {
                        self.result.entry(voltage_source_ac.id.clone()).or_insert(Complex::new(0.0, 0.0));
                        if voltage_source_ac.connection.from == "Ground" {
                            let eq = EquationComplex {
                                left_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("-{}",voltage_source_ac.connection.to), 
                                            denominator: Complex::new(-1.0, 0.0) 
                                        }
                                    ],
                                right_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("+{}",voltage_source_ac.id), 
                                            denominator: Complex::new(
                                                voltage_source_ac.voltage * voltage_source_ac.phase.to_radians().cos(),
                                                voltage_source_ac.voltage * voltage_source_ac.phase.to_radians().sin()
                                            )
                                        }
                                    ],
                            };
                            if !self.equations.contains(&eq) {
                                self.equations.push(eq);
                            };
                        } else if voltage_source_ac.connection.to == "Ground" {
                            let eq = EquationComplex {
                                left_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("+{}",voltage_source_ac.connection.from), 
                                            denominator: Complex::new(1.0, 0.0)
                                        }
                                    ],
                                right_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("+{}",voltage_source_ac.id), 
                                            denominator: Complex::new(
                                                voltage_source_ac.voltage * voltage_source_ac.phase.to_radians().cos(),
                                                voltage_source_ac.voltage * voltage_source_ac.phase.to_radians().sin()
                                            )
                                        }
                                    ],
                            };
                            if !self.equations.contains(&eq) {
                                self.equations.push(eq)
                            }
                        } else {
                            let eq = EquationComplex {
                                left_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("+{}",voltage_source_ac.connection.from), 
                                            denominator: Complex::new(1.0, 0.0)
                                        },
                                        ExpressionComplex { 
                                            numerator: format!("-{}",voltage_source_ac.connection.to), 
                                            denominator: Complex::new(-1.0, 0.0) 
                                        }
                                    ],
                                right_side: 
                                    vec![
                                        ExpressionComplex { 
                                            numerator: format!("+{}",voltage_source_ac.id), 
                                            denominator: Complex::new(
                                                voltage_source_ac.voltage * voltage_source_ac.phase.to_radians().cos(),
                                                voltage_source_ac.voltage * voltage_source_ac.phase.to_radians().sin()
                                            )
                                        }
                                    ],
                            };
                            if !self.equations.contains(&eq) {
                                self.equations.push(eq)
                            }
                        }
                        if voltage_source_ac.connection.from == node.id {
                            equation.left_side.push(
                                ExpressionComplex {
                                    numerator: format!("+{}",voltage_source_ac.id),
                                    denominator: Complex::new(1.0, 0.0),
                                }
                            )
                        } else {
                            equation.left_side.push(
                                ExpressionComplex {
                                    numerator: format!("-{}",voltage_source_ac.id),
                                    denominator: Complex::new(-1.0, 0.0),
                                }
                            )
                        }
                    },
                    crate::kernel::elements::element_type::ElementType::Capacitor(capacitor) => {
                        if capacitor.connection.from == node.id {
                            if capacitor.connection.to == "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, -1.0) / (2.0*3.14*self.circuit.frequency * capacitor.capacitance),
                                    }
                                );
                            } else if capacitor.connection.from == "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, -1.0) / (2.0*3.14*self.circuit.frequency * capacitor.capacitance),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",capacitor.connection.to),
                                        denominator: Complex::new(0.0, -1.0) / (-2.0*3.14*self.circuit.frequency * capacitor.capacitance),
                                    }
                                );
                            } else {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, -1.0) / (2.0*3.14*self.circuit.frequency * capacitor.capacitance),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",capacitor.connection.to),
                                        denominator: Complex::new(0.0, -1.0) / (-2.0*3.14*self.circuit.frequency * capacitor.capacitance),
                                    }
                                );
                            }
                        } else {
                            if capacitor.connection.from == "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, -1.0) / (2.0*3.14*self.circuit.frequency * capacitor.capacitance),
                                    }
                                );
                            } else if capacitor.connection.to== "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, -1.0) / (-2.0*3.14*self.circuit.frequency * capacitor.capacitance),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",capacitor.connection.from),
                                        denominator: Complex::new(0.0, -1.0) / (-2.0*3.14*self.circuit.frequency * capacitor.capacitance),
                                    }
                                );
                            } else {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, -1.0) / (2.0*3.14*self.circuit.frequency * capacitor.capacitance),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",capacitor.connection.from),
                                        denominator: Complex::new(0.0, -1.0) / (-2.0*3.14*self.circuit.frequency * capacitor.capacitance),
                                    }
                                );
                            }
                        }
                    },
                    crate::kernel::elements::element_type::ElementType::Inductor(inductor) => {
                        if inductor.connection.from == node.id {
                            if inductor.connection.to == "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, 1.0) * (2.0*3.14*self.circuit.frequency * inductor.inductance),
                                    }
                                );
                            } else if inductor.connection.from == "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, 1.0) * (2.0*3.14*self.circuit.frequency * inductor.inductance),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",inductor.connection.to),
                                        denominator: Complex::new(0.0, 1.0) * (-2.0*3.14*self.circuit.frequency * inductor.inductance),
                                    }
                                );
                            } else {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, 1.0) * (2.0*3.14*self.circuit.frequency * inductor.inductance),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",inductor.connection.to),
                                        denominator: Complex::new(0.0, 1.0) * (-2.0*3.14*self.circuit.frequency * inductor.inductance),
                                    }
                                );
                            }
                        } else {
                            if inductor.connection.from == "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, 1.0) * (2.0*3.14*self.circuit.frequency * inductor.inductance),
                                    }
                                );
                            } else if inductor.connection.to== "Ground" {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, 1.0) * (-2.0*3.14*self.circuit.frequency * inductor.inductance),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",inductor.connection.from),
                                        denominator: Complex::new(0.0, 1.0) * (-2.0*3.14*self.circuit.frequency * inductor.inductance),
                                    }
                                );
                            } else {
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("+{}",node.id),
                                        denominator: Complex::new(0.0, 1.0) * (2.0*3.14*self.circuit.frequency * inductor.inductance),
                                    }
                                );
                                equation.left_side.push(
                                    ExpressionComplex {
                                        numerator: format!("-{}",inductor.connection.from),
                                        denominator: Complex::new(0.0, 1.0) * (-2.0*3.14*self.circuit.frequency * inductor.inductance),
                                    }
                                );
                            }
                        }
                    },
                }
            }
            if equation.right_side.is_empty() { 
                equation.right_side.push(
                    ExpressionComplex {
                        numerator: format!("0"),
                        denominator: Complex::new(0.0, 0.0),
                    }
                )
            }
            self.equations.push(equation);
        }
        self.equations.clone()
    }        
}